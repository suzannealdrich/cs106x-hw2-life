/*  * * File:   life.c * Author: Suzanne Aldrich * Date:   10/10/97 * ------------ * Life simulation. * */#include <stdio.h>#include <stdlib.h>#include "genlib.h"#include "extgraph.h"#include "strlib.h"#include "grid.h"#include "simpio.h"#include "random.h"			typedef enum { Plateau = 1, Mirror, Torus } mode;typedef enum { FileInit = 1, RandomInit, SelfInit } init;void Intro(void);void Exit(void);void Simulation();bool BoolQuestion(string prompt);int IntQuestion(string prompt, int min, int max);double DoubleQuestion(string prompt, double min, double max);gridADT FileInitGrid();gridADT RandomInitGrid();gridADT SelfInitGrid();void CalculateCells(gridADT readgrid, gridADT writegrid, mode currentmode);int CountNeighbors(int x, int y, gridADT readgrid, mode currentmode);main() {		InitGraphics();	Randomize();	Intro();	do Simulation(); while (BoolQuestion("Another Life? (Y/N) "));	Exit();	ExitGraphics();}void Intro(void){		SetWindowTitle("Life");	SetFont("Palatino");	SetPointSize(48);	MovePen((GetWindowWidth() - TextStringWidth("Life")) / 2, 			(GetWindowHeight() - GetFontAscent()) / 2);	DrawTextString("Life");	printf("Please set your monitor to 256 color mode.\n");	printf("Welcome to Life.\n");	printf("The object of Life is to stay alive.\n");	printf("Press return to start playing.\n");	GetLine();}void Exit(void){	printf("\nEnd of Life.\n");	printf("Created by aigeanta@stanford.edu\n");	printf("Press return to exit.\n");	GetLine();}void Simulation(){	init currentinit;	mode currentmode;	int generation = 0;	gridADT readgrid, writegrid;		InitGraphics();	printf("Choose initialization method:\n");    currentinit = (init) IntQuestion("1. Pre-Determined\n2. Random\n3. Self-Defined", 1, 3);		switch (currentinit) {		case FileInit:      readgrid = FileInitGrid();      break;		case RandomInit:    readgrid = RandomInitGrid();    break;		case SelfInit:		readgrid = SelfInitGrid();		break;	}		writegrid = CreateGrid(NumRows(readgrid), NumCols(readgrid));	printf("Choose mode:\n");	currentmode = (mode) IntQuestion("1. Plateau\n2. Mirror\n3. Torus", 1, 3);	printf("Click the simulation window to stop Life.\n");	while(!MouseButtonIsDown()) {		CalculateCells(readgrid, writegrid, currentmode);		generation++;		DrawGrid(writegrid);		UpdateDisplay();		CopyGrid(writegrid, readgrid);		}	printf("Life Stopped.\n");	printf("Generations: %d\n", generation);	FreeGrid(readgrid);	FreeGrid(writegrid);}		gridADT FileInitGrid(){	FILE *initfile;	string filename, line;	char ch;	gridADT readgrid;	int x, y, numrows, numcols;		//  Re-prompt until valid filename.	while (TRUE) {		printf("Choose initialization file:\n");		printf("Cheshire    Glider    Flower  Spaceships\n");		printf("Snowflake   Figure 8  Seeds   Simple Bar\n");		printf("Glider Gun  Mirror    Spiral  TicTacToe\n");		printf("?  ");		filename = GetLine();		initfile = fopen(filename, "r");		if (initfile != NULL)  break;		printf("That file is non-existant.\n");  	}		numrows = StringToInteger(ReadLine(initfile));	numcols = StringToInteger(ReadLine(initfile));	readgrid = CreateGrid(numrows, numcols);			for (x = 0; x < numrows; x++) {		line = ReadLine(initfile);		if (line == NULL) break;		for (y = 0; y < numcols; y++) {			ch = IthChar(line, y);			switch (ch) { 				case '-':	SetValueAt(readgrid, x, y, 0);	break; 				case 'X':	SetValueAt(readgrid, x, y, 1);	break; 			} 		} 	} 		fclose(initfile);	DrawGrid(readgrid);	return (readgrid);}gridADT RandomInitGrid(){	int x, y;	int numrows = IntQuestion("Number of Rows (0 - 48)", 0, MAX_ROWS);	int numcols = IntQuestion("Number of Columns (0 - 64)", 0, MAX_COLS);	double probability = DoubleQuestion("Choose a probability (0.0 - 1.0)", 0, 1);	gridADT readgrid = CreateGrid(numrows, numcols); 	for (x = 0; x < numrows; x++) {		for (y = 0; y < numcols; y++) { 			SetValueAt(readgrid, x, y, RandomChance(probability)); 		} 	}	DrawGrid(readgrid);	return (readgrid);}gridADT SelfInitGrid(){	int x, y;	int numrows = IntQuestion("Number of Rows (0 - 48)", 0, MAX_ROWS);	int numcols = IntQuestion("Number of Columns (0 - 64)", 0, MAX_COLS);	gridADT readgrid = CreateGrid(numrows, numcols);		printf("Choose the coordinates of each cell:\n");		do { 		x = IntQuestion("Row #", 0, numrows);		y = IntQuestion("Col #", 0, numcols);		SetValueAt(readgrid, x, y, 1);		DrawGrid(readgrid);	} while (BoolQuestion("Another cell? (Y/N) "));	return (readgrid);}void CalculateCells(gridADT readgrid, gridADT writegrid, mode currentmode){	int x, y, age = 0, count = 0;	int numrows = NumRows(readgrid), numcols = NumCols(readgrid);	for (x = 0; x < numrows; x++) {				for (y = 0; y < numcols; y++) {			age = GetValueAt(readgrid, x, y);			count = CountNeighbors(x, y, readgrid, currentmode);						//  Alive?			if (age > 0) {  	   			if (count != 2 && count != 3) {	   				//  Kill the lonely/overcrowded cells.	   				SetValueAt(writegrid, x, y , 0);  	   			} else {	   				//  Age the surviving cells.	   				SetValueAt(writegrid, x, y , ++age);  	   			}	    	} else {	    		if (count == 3) {	    			//  Create a cell.	    			SetValueAt(writegrid, x, y , 1);  	    		}					} 		}			}}int CountNeighbors(int x, int y, gridADT readgrid, mode currentmode) {		int numrows = NumRows(readgrid), numcols = NumCols(readgrid);	int dx, dy, total = 0;	bool xout, yout;	for (dx = -1; dx <= 1; dx++) {		//  Is the x coordinate out of bounds?		xout = x + dx < 0  ||  numrows <= x + dx;  				for (dy = -1; dy <= 1; dy++) {			// Is the y coordinate out of bounds?			yout = y + dy < 0  ||  numcols <= y + dy;  						if (xout || yout)  { switch (currentmode) {				case  Plateau:  					//  Don't increment total since no cells exist out of bounds.					break;				case  Mirror:					//  Reflect in bounds; if cell exists, increment total.					if (GetValueAt(readgrid, (xout ? x : x + dx), (yout ? y : y + dy))) {						total++;					}					break;				case  Torus:					//  Wraparound in bounds via mod; if cell exists, increment total.					if (GetValueAt(readgrid, (x + dx + numrows) % numrows, 								  (y + dy + numcols) % numcols)) {						total++;					}					break;				}			} else {				//  Increment total if the neighbor is not itself and a cell exists.				if ((dx || dy) && GetValueAt(readgrid, x + dx, y + dy)) {  					total++;				}			}		}	}	return (total);}//   Count// Neighbors//  dx | dy//  _______	//  -1 | -1//  -1 |  0//  -1 |  1//   0 | -1//   0 |  0 *//   0 |  1//   1 | -1//   1 |  0//   1 |  1int IntQuestion(string prompt, int min, int max){	int variable;		//  Re-prompt while variable is out-of-bounds.	do {		printf("%s\n?  ", prompt);		variable = GetInteger();	} while (variable < min || max < variable); 	return (variable);}double DoubleQuestion(string prompt, double min, double max){	double variable;		do {		printf("%s\n?  ", prompt);		variable = GetReal();	} while (variable < min || max < variable);	return (variable);}bool BoolQuestion(string prompt){  string answer;  bool result;  printf("%s", prompt);  answer = ConvertToUpperCase(GetLine());  if (StringEqual(answer, "Y")) {    result = TRUE;  } else if (StringEqual(answer, "N")) {    result = FALSE;  } else {    printf("Choose either Y or N.\n");    result = BoolQuestion(prompt);  }  return (result);}